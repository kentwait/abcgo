package abcgo

import (
	"math"
	"math/rand"
)

// Generator is a data generating function that outputs data based on
// a set of input parameters.
type Generator func(...float64) []float64

// RejectionSampler implements the ABC rejection algorithm.
// In this method, parameters are generated by sampling a parameter space as
// uniformly. Proposed parameters are accepted or rejected based on a
// similarity metric computed between the observed data and the simulated
// data generated using the parameters.
func RejectionSampler(y []float64, tolerance float64, paramProposers *Proposers, dataGenerator Generator, paramFilterer Filter) []float64 {
	// sample new parameters from parameter generator
	params := paramProposers.Propose()

	// generate new data x based on parameters
	x := dataGenerator(params...)

	if paramFilterer(y, x, tolerance) == false {
		// store theta if within tolerance
		return nil
	}
	return params
}

// RejectionSamplerN performs ABC rejection sampling over n number of rounds.
func RejectionSamplerN(n int64, y []float64, tolerance float64,
	paramProposers Proposers, dataGenerator Generator, paramFilterer Filter) (acceptedParams [][]float64) {
	// n is number of trials

	for t := int64(0); t < n; t++ {
		p := RejectionSampler(y, tolerance, &paramProposers, dataGenerator, paramFilterer)
		acceptedParams = append(acceptedParams, p)
	}
	return
}

type RandomWalker func([]float64, []float64) float64

func MCMCSampler(priorParams, y []float64, tolerance float64, paramProposers *Proposers, dataGenerator Generator, paramFilterer Filter, randomWalker RandomWalker) ([]float64, bool) {
	// propose new parameters from parameter generator based on the
	// previous accepted parameter
	newParams := paramProposers.Propose()

	// generate new data x based on parameters
	x := dataGenerator(newParams...)

	// Test whether generated data is close enough to the observed
	// data. If not, stay at previous parameters and try again
	if paramFilterer(y, x, tolerance) == false {
		// store theta if within tolerance
		return priorParams, false

	}
	// Calculate acceptance probability h
	// TODO
	q := randomWalker(priorParams, newParams)
	pi := paramProposers.TotalProb(priorParams...) / paramProposers.TotalProb(newParams...)
	h := math.Min(float64(1), pi*q)

	// Accept new parameters with probability h.
	// Otherwise, stay at previous parameters and try again
	if h <= rand.Float64() {
		return newParams, true
	}
	return priorParams, false
}

// MCMCSamplerN implements the ABC Markov chain Monte Carlo algorithm.
// In this method, new parameters are proposed by random walk exploring the
// neighborhood of the last accepted parameter.
func MCMCSamplerN(n int64, y []float64, tolerance float64, paramProposers Proposers, dataGenerator Generator, paramFilterer Filter, randomWalker RandomWalker) (acceptedParams [][]float64) {
	var priorParams, newParams []float64
	isNew := false
	for {
		priorParams = RejectionSampler(y, tolerance, &paramProposers, dataGenerator, paramFilterer)

		if priorParams != nil {
			break
		}
	}

	for i := int64(0); i < n; i++ {
		newParams, isNew = MCMCSampler(priorParams, y, tolerance, &paramProposers, dataGenerator, paramFilterer, randomWalker)
		acceptedParams = append(acceptedParams, newParams)

		if isNew {
			priorParams = newParams
			for i, param := range newParams {
				paramProposers[i].UpdateFields(param)
			}
		}
	}
	return
}
